<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<title>Editor de Questões</title>
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.tiny.cloud/1/wngoh8cdfbnclgn1ulvujvsb6dj9l76xarp1im1r3wt2zhh9/tinymce/5/tinymce.min.js" referrerpolicy="origin"></script>
<style>
    body {
        background-color: #f9f9f9;
        font-family: 'Roboto', sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
    }

    #uploadBox {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        padding: 40px;
        text-align: center;
        max-width: 400px;
        width: 100%;
    }

    #uploadBox h2 {
        color: #333;
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    #uploadIcon {
        font-size: 36px;
        margin-right: 10px;
        color: #2196F3;
    }

    #fileLabel {
        background-color: #2196F3;
        border: none;
        border-radius: 4px;
        color: #fff;
        cursor: pointer;
        font-size: 16px;
        padding: 10px 20px;
        transition: background-color 0.3s ease;
        display: block;
        margin: 0 auto 20px;
        width: fit-content;
    }

    #fileLabel:hover {
        background-color: #1976D2;
    }

    #processButton {
        background-color: #4CAF50;
        border: none;
        border-radius: 4px;
        color: #fff;
        cursor: pointer;
        font-size: 16px;
        padding: 10px 20px;
        transition: background-color 0.3s ease;
        display: block;
        margin: 0 auto;
        width: fit-content;
    }

    #processButton:hover {
        background-color: #388E3C;
    }

    #uploadBox input[type="file"] {
        display: none;
    }

    #trailName {
        width: 100%;
        padding: 10px;
        margin-bottom: 20px;
        font-size: 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }

    .container {
        margin-top: auto;
    }

    .mt-3, .my-3 {
        margin-top: auto !important;
    }
    
    .modal-lg { 
        max-width: 90%; 
    }
    
    .correct { 
        background-color: lightgreen; 
    }
    
    .incorrect { 
        background-color: lightcoral; 
    }
    
    .feedback { 
        margin-left: 30px; 
        background-color: #f0f0f0; 
        padding: 10px; 
        border-radius: 5px; 
    }
    
    .feedback-editor { 
        background-color: #f5f5f5; 
    }
</style>
</head>
<body>
<div id="uploadBox">
    <h2>Editor de Questões</h2>
    <label id="fileLabel" for="fileInput">Escolher Arquivo</label>
    <input type="file" id="fileInput" accept=".txt">
    <input type="text" id="trailName" placeholder="Nome da trilha">
    <button id="processButton">Abrir edição</button>
</div>

<!-- Área onde o conteúdo processado será exibido para edição -->
<div class="container mt-3" style="display:none">
    <h2>Editor de Questões</h2><br>
    <div id="trailContainer">
        <!-- Questões processadas e suas áreas de edição serão exibidas aqui -->
    </div><br>
    <button id="downloadChanges" class="btn btn-success mt-3">Download Alterações</button>
    <br>
</div>

<!-- Modal para edição de questões -->
<div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true" data-backdrop="static">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="editModalLabel">Editar Questão</h5>
        <button type="button" class="close" id="modalClose" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <form id="editForm">
          <div class="form-group">
            <label for="questionName">Nome da Questão:</label>
            <input type="text" id="questionName" class="form-control">
          </div>
          <div class="form-group">
            <label for="questionText">Enunciado:</label>
            <textarea id="questionText" class="form-control"></textarea>
          </div>
          <div id="alternativesContainer" class="form-group">
            <!-- Alternativas serão adicionadas dinamicamente -->
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="cancelChanges">Cancelar</button>
        <button type="button" class="btn btn-primary" id="saveChanges">Salvar Alterações</button>
      </div>
    </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
<script src="processador.js"></script>
<script>
let questionsData = []; // Armazena as questões globalmente
let originalFileContent = ""; // Armazena o conteúdo original do arquivo
let isModified = false; // Flag para monitorar se o conteúdo foi modificado

$(document).ready(function() {
  $('#processButton').on('click', function() {
    const fileInput = $('#fileInput')[0].files[0];
    if (!fileInput) {
      alert('Por favor, selecione um arquivo.');
      return;
    }

    const reader = new FileReader();
    reader.onload = function(e) {
      originalFileContent = e.target.result;

      // Processar o arquivo cru com o processador.js e modelo.txt
      processFiles([fileInput], 'nomeDaTrilha');  // Aqui o nome da trilha pode ser substituído ou configurado

      // O conteúdo final será gerado após processar o arquivo
      setTimeout(function(){
        const processedContent = processedData.join('\n'); // processedData vem do processador.js
        processFileContent(processedContent);
        $('#uploadBox').hide();
        $('.container').show();
      }, 1000);
    };
    reader.readAsText(fileInput);
  });

  function processFileContent(content) {
    const questions = content.split('// question:').slice(1);

    questionsData = questions.map((questionText, index) => {
      if (questionText.includes('Switch category to $course$/top/')) return null;

      const nameMatch = questionText.match(/name: (.+?)\n/);
      let htmlMatch = questionText.match(/\[html\](.+?)\{/s);
      
      if (htmlMatch) {
        htmlMatch = htmlMatch[1].replace(/\\/g, "");  // Remove todas as barras invertidas
      }

      const alternatives = extractAlternatives(questionText);

      const questionName = nameMatch ? nameMatch[1].trim() : '';
      const unitMatch = questionName.match(/Q_\d{2}_(UN|U)_(\d{2})/);

      if (unitMatch) {
        const unitNumber = parseInt(unitMatch[2], 10);
        const trailNumber = Math.ceil(unitNumber / 5);
        const trail = `Trilha ${trailNumber}`;

        return {
          id: index + 1,
          name: questionName,
          trail: trail,
          originalText: questionText,
          html: htmlMatch ? htmlMatch.trim() : '',
          alternatives: alternatives
        };
      }
      return null;
    }).filter(Boolean);

    renderQuestions();
  }

  function renderQuestions() {
    const trailContainer = $('#trailContainer');
    trailContainer.empty();

    const groupedByTrail = questionsData.reduce((acc, question) => {
      const trail = question.trail;
      acc[trail] = acc[trail] || [];
      acc[trail].push(question);
      return acc;
    }, {});

    Object.keys(groupedByTrail).forEach(trail => {
      const trailDiv = $('<div>').addClass('trail').append(`<h3>${trail}</h3>`);
      const table = $('<table>').addClass('table table-bordered');
      const tableHead = $('<thead><tr><th>Questão</th><th>Enunciado</th><th>Ações</th></tr></thead>');
      const tableBody = $('<tbody></tbody>');

      groupedByTrail[trail].forEach((question) => {
        const row = $('<tr>');
        const nameCell = $('<td>').text(question.name);
        const htmlCell = $('<td>').html(question.html.substring(0, 100) + '...');
        const editButton = $('<button>').addClass('btn btn-primary').text('Editar').data('question-id', question.id);

        editButton.on('click', function() {
          const questionId = $(this).data('question-id');
          loadQuestionModal(questionId);
          $('#editModal').modal('show');
        });

        const actionsCell = $('<td>').append(editButton);
        row.append(nameCell, htmlCell, actionsCell);
        tableBody.append(row);
      });

      table.append(tableHead).append(tableBody);
      trailDiv.append(table);
      trailContainer.append(trailDiv);
    });
  }

  function extractAlternatives(questionText) {
    const regex = /([~=])([^\n#]+)#([^\n]*)/g;
    let match;
    const alternatives = [];
    while ((match = regex.exec(questionText)) !== null) {
      const text = match[2].replace(/\\/g, "").trim();
      const feedback = match[3].replace(/\\/g, "").trim();

      alternatives.push({
        isCorrect: match[1] === '=',
        text: text,
        feedback: feedback
      });
    }
    return alternatives;
  }

function exibirConteudoEditavel(content) {
    // Parse o conteúdo processado e o exiba na área de edição

    const trailContainer = document.getElementById('trailContainer');
    trailContainer.innerHTML = '';  // Limpar qualquer conteúdo existente

    // Aqui assumimos que o conteúdo está separado por questões
    const questions = content.split('// question:').slice(1);

    questions.forEach((questionText, index) => {
        const questionDiv = document.createElement('div');
        questionDiv.classList.add('question');

        const title = document.createElement('h3');
        title.innerText = `Questão ${index + 1}`;
        questionDiv.appendChild(title);

        const textArea = document.createElement('textarea');
        textArea.classList.add('form-control');
        textArea.value = questionText.trim(); // Exibir o conteúdo da questão para edição
        questionDiv.appendChild(textArea);

        trailContainer.appendChild(questionDiv);
    });

    // Mostra a área de edição e oculta a caixa de upload
    $('#uploadBox').hide();
    $('.container').show();
}


    
  function loadQuestionModal(questionId) {
    isModified = false;
    const question = questionsData.find(q => q.id === questionId);
    $('#editForm').data('question-id', question.id);
    $('#questionName').val(question.name);

    tinymce.init({
        selector: '#questionText',
        height: 300,
        menubar: false,
        plugins: [
            'advlist autolink lists link image charmap print preview anchor',
            'searchreplace visualblocks code fullscreen',
            'insertdatetime media table paste code help wordcount',
            'image code'
        ],
        toolbar: 'undo redo | formatselect | bold italic backcolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | removeformat | image | code',
        setup: function(editor) {
            editor.on('init', function() {
                tinymce.get('questionText').setContent(question.html);
            });
            editor.on('change', function() {
                isModified = true;
            });
        }
    });

    const container = $('#alternativesContainer');
    container.empty();

    question.alternatives.forEach((alt, index) => {
      const altHtml = $('<textarea>').addClass('form-control my-2 question-editor').val(alt.text);
      const feedbackHtml = $('<textarea>').addClass('form-control my-2 feedback-editor feedback').val(alt.feedback);

      const label = $('<label>').text(`Alternativa ${index + 1}`);
      const feedbackLabel = $('<label>').text(`Feedback - Alternativa ${index + 1}`);
      const selectHtml = $('<select>').addClass('form-control mb-2')
        .html(`<option value="false"${!alt.isCorrect ? ' selected' : ''}>Incorreta</option>
               <option value="true"${alt.isCorrect ? ' selected' : ''}>Correta</option>`)
        .addClass(alt.isCorrect ? 'correct' : 'incorrect');

      const div = $('<div>').addClass('form-group').append(label, selectHtml, altHtml, feedbackLabel, feedbackHtml);
      container.append(div);
    });
  }

  $('#saveChanges').on('click', function() {
    const questionId = $('#editForm').data('question-id');
    const question = questionsData.find(q => q.id === questionId);
    question.name = $('#questionName').val();
    question.html = tinymce.get('questionText').getContent();

    $('#alternativesContainer .form-group').each(function(index) {
      const altText = $(this).find('.question-editor').val();
      const feedbackText = $(this).find('.feedback-editor').val();
      const isCorrect = $(this).find('select').val() === 'true';
      question.alternatives[index].text = altText;
      question.alternatives[index].feedback = feedbackText;
      question.alternatives[index].isCorrect = isCorrect;
    });

    renderQuestions();
    $('#editModal').modal('hide');
    isModified = false;
  });

  $('#modalClose, #cancelChanges').on('click', function() {
    if (isModified) {
      if (confirm("Você tem alterações não salvas. Deseja realmente sair sem salvar?")) {
        $('#editModal').modal('hide');
      }
    } else {
      $('#editModal').modal('hide');
    }
  });

  $('#editModal').on('hide.bs.modal', function () {
    tinymce.remove('.question-editor');
    tinymce.remove('#questionText');
  });

  $('#downloadChanges').on('click', function() {
    let updatedContent = originalFileContent;

    questionsData.forEach(question => {
        const questionText = question.originalText;
        const updatedHtml = question.html;

        const updatedAlternatives = question.alternatives.map(alt => {
            const correctSymbol = alt.isCorrect ? '=' : '~';
            return `${correctSymbol}${alt.text}#${alt.feedback}`;
        }).join('\n');

        const regexAlternatives = /([~=])([^\n#]+)#([^\n]*)/g;
        let alternativeIndex = 0;

        updatedContent = updatedContent.replace(questionText, questionText.replace(/\[html\](.+?)\{/, `[html]${updatedHtml}{`).replace(regexAlternatives, function(match, p1, p2, p3) {
            const updatedAlt = updatedAlternatives.split('\n')[alternativeIndex++];
            return updatedAlt ? updatedAlt : match;
        }));
    });

    const blob = new Blob([updatedContent], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'questoes_alteradas.txt';
    link.click();
  });
});
</script>
</body>
</html>
